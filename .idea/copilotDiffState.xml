<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="updatedContent" value="# Python&#10;__pycache__/&#10;*.py[cod]&#10;*.pyo&#10;*.pyd&#10;*.env&#10;*.venv&#10;venv/&#10;env/&#10;&#10;# VSCode&#10;.vscode/&#10;&#10;# macOS&#10;.DS_Store&#10;&#10;# Linux&#10;*.swp&#10;&#10;# Node.js&#10;node_modules/&#10;youtube-downloader-frontend/node_modules/&#10;&#10;# Logs&#10;*.log&#10;&#10;# Temp files&#10;*.tmp&#10;*.bak&#10;&#10;# Output&#10;*.mp4&#10;*.m4a&#10;*.webm&#10;*.part&#10;*.crdownload&#10;&#10;# Frontend build&#10;youtube-downloader-frontend/.next/&#10;youtube-downloader-frontend/out/&#10;&#10;# Misc&#10;*.sqlite3&#10;*.db&#10;&#10;# Ignore downloads&#10;/tmp/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import shutil&#10;import tempfile&#10;import yt_dlp&#10;from fastapi import FastAPI, HTTPException, BackgroundTasks&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from pydantic import BaseModel&#10;from starlette.responses import FileResponse&#10;&#10;app = FastAPI()&#10;origins = [&quot;http://localhost:3000&quot;]&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=origins,&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;&#10;class VideoRequest(BaseModel):&#10;    url: str&#10;&#10;&#10;class DownloadRequest(BaseModel):&#10;    url: str&#10;    quality_label: str&#10;&#10;&#10;def cleanup_directory(path: str):&#10;    if os.path.isdir(path):&#10;        shutil.rmtree(path)&#10;&#10;&#10;@app.post(&quot;/api/info&quot;)&#10;def get_video_info(request: VideoRequest):&#10;    ydl_opts = {'quiet': True}&#10;    try:&#10;        with yt_dlp.YoutubeDL(ydl_opts) as ydl:&#10;            info = ydl.extract_info(request.url, download=False)&#10;&#10;            qualities = set()&#10;            for f in info.get('formats', []):&#10;                if f.get('vcodec') != 'none' and f.get('acodec') == 'none' and f.get('height'):&#10;                    qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            if not qualities:  # Fallback for videos with combined formats only&#10;                for f in info.get('formats', []):&#10;                    if f.get('vcodec') != 'none' and f.get('height'):&#10;                        qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            sorted_qualities = sorted(list(qualities), key=lambda x: int(x.replace('p', '')), reverse=True)&#10;&#10;            return {&#10;                &quot;title&quot;: info.get(&quot;title&quot;, &quot;No title&quot;),&#10;                &quot;thumbnail&quot;: info.get(&quot;thumbnail&quot;, &quot;&quot;),&#10;                &quot;qualities&quot;: sorted_qualities,&#10;            }&#10;    except Exception as e:&#10;        raise HTTPException(status_code=400, detail=str(e))&#10;&#10;&#10;@app.post(&quot;/api/download&quot;)&#10;async def download_video(request: DownloadRequest, background_tasks: BackgroundTasks):&#10;    temp_dir = tempfile.mkdtemp()&#10;    background_tasks.add_task(cleanup_directory, temp_dir)&#10;&#10;    try:&#10;        # --- Stage 1: Always download the best quality to avoid 403 errors ---&#10;        source_path_template = os.path.join(temp_dir, 'source_video')&#10;        source_path_final = f&quot;{source_path_template}.mp4&quot;&#10;&#10;        ydl_opts_best = {&#10;            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',&#10;            'outtmpl': source_path_template,&#10;            'quiet': True,&#10;            'merge_output_format': 'mp4',&#10;        }&#10;&#10;        with yt_dlp.YoutubeDL(ydl_opts_best) as ydl:&#10;            info = ydl.extract_info(request.url, download=True)&#10;            title = info.get(&quot;title&quot;, &quot;video&quot;)&#10;            # Get the actual height of the video we just downloaded&#10;            actual_height = info.get('height')&#10;&#10;        if not os.path.exists(source_path_final):&#10;            raise HTTPException(status_code=500, detail=&quot;Failed to download the source video.&quot;)&#10;&#10;        # --- Stage 2: Check if re-encoding is necessary ---&#10;        requested_height = int(re.search(r'(\d+)p', request.quality_label).group(1))&#10;&#10;        # If requested quality is the same or higher than best, no need to re-encode&#10;        if requested_height &gt;= actual_height:&#10;            safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;            return FileResponse(path=source_path_final, media_type='video/mp4', filename=safe_filename)&#10;&#10;        # --- Stage 3: Re-encode to the desired lower quality ---&#10;        final_path = os.path.join(temp_dir, 'final_video.mp4')&#10;&#10;        # This ffmpeg command scales the video down to the requested height&#10;        ffmpeg_command = [&#10;            'ffmpeg',&#10;            '-i', source_path_final,&#10;            '-vf', f'scale=-2:{requested_height}',  # -2 maintains aspect ratio&#10;            '-c:a', 'copy',  # Copy the audio stream without re-encoding&#10;            final_path&#10;        ]&#10;&#10;        # Using subprocess.run to execute the command&#10;        process = subprocess.run(&#10;            ffmpeg_command,&#10;            capture_output=True,&#10;            text=True,&#10;            check=False  # Set to False to check stderr manually&#10;        )&#10;&#10;        if process.returncode != 0:&#10;            # If ffmpeg fails, raise an error with its output for debugging&#10;            print(&quot;FFmpeg Error:&quot;, process.stderr)&#10;            raise HTTPException(status_code=500, detail=f&quot;FFmpeg re-encoding failed: {process.stderr}&quot;)&#10;&#10;        if not os.path.exists(final_path):&#10;            raise HTTPException(status_code=500, detail=&quot;Re-encoding failed to produce an output file.&quot;)&#10;&#10;        safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;        return FileResponse(path=final_path, media_type='video/mp4', filename=safe_filename)&#10;&#10;    except Exception as e:&#10;        if isinstance(e, HTTPException):&#10;            raise e&#10;        print(f&quot;An error occurred in /api/download: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=str(e))" />
              <option name="updatedContent" value="import os&#10;import re&#10;import shutil&#10;import subprocess&#10;import tempfile&#10;import yt_dlp&#10;from fastapi import FastAPI, HTTPException, BackgroundTasks&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from pydantic import BaseModel&#10;from starlette.responses import FileResponse&#10;&#10;app = FastAPI()&#10;origins = [&quot;http://localhost:3000&quot;]&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=origins,&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;&#10;class VideoRequest(BaseModel):&#10;    url: str&#10;&#10;&#10;class DownloadRequest(BaseModel):&#10;    url: str&#10;    quality_label: str&#10;&#10;&#10;def cleanup_directory(path: str):&#10;    if os.path.isdir(path):&#10;        shutil.rmtree(path)&#10;&#10;&#10;@app.post(&quot;/api/info&quot;)&#10;def get_video_info(request: VideoRequest):&#10;    ydl_opts = {'quiet': True}&#10;    try:&#10;        with yt_dlp.YoutubeDL(ydl_opts) as ydl:&#10;            info = ydl.extract_info(request.url, download=False)&#10;&#10;            qualities = set()&#10;            for f in info.get('formats', []):&#10;                if f.get('vcodec') != 'none' and f.get('acodec') == 'none' and f.get('height'):&#10;                    qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            if not qualities:  # Fallback for videos with combined formats only&#10;                for f in info.get('formats', []):&#10;                    if f.get('vcodec') != 'none' and f.get('height'):&#10;                        qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            sorted_qualities = sorted(list(qualities), key=lambda x: int(x.replace('p', '')), reverse=True)&#10;&#10;            return {&#10;                &quot;title&quot;: info.get(&quot;title&quot;, &quot;No title&quot;),&#10;                &quot;thumbnail&quot;: info.get(&quot;thumbnail&quot;, &quot;&quot;),&#10;                &quot;qualities&quot;: sorted_qualities,&#10;            }&#10;    except Exception as e:&#10;        raise HTTPException(status_code=400, detail=str(e))&#10;&#10;&#10;@app.post(&quot;/api/download&quot;)&#10;async def download_video(request: DownloadRequest, background_tasks: BackgroundTasks):&#10;    temp_dir = tempfile.mkdtemp()&#10;    background_tasks.add_task(cleanup_directory, temp_dir)&#10;&#10;    try:&#10;        # --- Stage 1: Always download the best quality to avoid 403 errors ---&#10;        source_path_template = os.path.join(temp_dir, 'source_video')&#10;        source_path_final = f&quot;{source_path_template}.mp4&quot;&#10;&#10;        ydl_opts_best = {&#10;            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',&#10;            'outtmpl': source_path_template,&#10;            'quiet': True,&#10;            'merge_output_format': 'mp4',&#10;        }&#10;&#10;        with yt_dlp.YoutubeDL(ydl_opts_best) as ydl:&#10;            info = ydl.extract_info(request.url, download=True)&#10;            title = info.get(&quot;title&quot;, &quot;video&quot;)&#10;            # Get the actual height of the video we just downloaded&#10;            actual_height = info.get('height')&#10;&#10;        if not os.path.exists(source_path_final):&#10;            raise HTTPException(status_code=500, detail=&quot;Failed to download the source video.&quot;)&#10;&#10;        # --- Stage 2: Check if re-encoding is necessary ---&#10;        requested_height = int(re.search(r'(\d+)p', request.quality_label).group(1))&#10;&#10;        # If requested quality is the same or higher than best, no need to re-encode&#10;        if requested_height &gt;= actual_height:&#10;            safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;            return FileResponse(path=source_path_final, media_type='video/mp4', filename=safe_filename)&#10;&#10;        # --- Stage 3: Re-encode to the desired lower quality ---&#10;        final_path = os.path.join(temp_dir, 'final_video.mp4')&#10;&#10;        # This ffmpeg command scales the video down to the requested height&#10;        ffmpeg_command = [&#10;            'ffmpeg',&#10;            '-i', source_path_final,&#10;            '-vf', f'scale=-2:{requested_height}',  # -2 maintains aspect ratio&#10;            '-c:a', 'copy',  # Copy the audio stream without re-encoding&#10;            final_path&#10;        ]&#10;&#10;        # Using subprocess.run to execute the command&#10;        process = subprocess.run(&#10;            ffmpeg_command,&#10;            capture_output=True,&#10;            text=True,&#10;            check=False  # Set to False to check stderr manually&#10;        )&#10;&#10;        if process.returncode != 0:&#10;            # If ffmpeg fails, raise an error with its output for debugging&#10;            print(&quot;FFmpeg Error:&quot;, process.stderr)&#10;            raise HTTPException(status_code=500, detail=f&quot;FFmpeg re-encoding failed: {process.stderr}&quot;)&#10;&#10;        if not os.path.exists(final_path):&#10;            raise HTTPException(status_code=500, detail=&quot;Re-encoding failed to produce an output file.&quot;)&#10;&#10;        safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;        return FileResponse(path=final_path, media_type='video/mp4', filename=safe_filename)&#10;&#10;    except Exception as e:&#10;        if isinstance(e, HTTPException):&#10;            raise e&#10;        print(f&quot;An error occurred in /api/download: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=str(e))" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>