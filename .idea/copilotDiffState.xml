<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="updatedContent" value="# Python&#10;__pycache__/&#10;*.py[cod]&#10;*.pyo&#10;*.pyd&#10;*.env&#10;*.venv&#10;venv/&#10;env/&#10;&#10;# VSCode&#10;.vscode/&#10;&#10;# macOS&#10;.DS_Store&#10;&#10;# Linux&#10;*.swp&#10;&#10;# Node.js&#10;node_modules/&#10;youtube-downloader-frontend/node_modules/&#10;&#10;# Logs&#10;*.log&#10;&#10;# Temp files&#10;*.tmp&#10;*.bak&#10;&#10;# Output&#10;*.mp4&#10;*.m4a&#10;*.webm&#10;*.part&#10;*.crdownload&#10;&#10;# Frontend build&#10;youtube-downloader-frontend/.next/&#10;youtube-downloader-frontend/out/&#10;&#10;# Misc&#10;*.sqlite3&#10;*.db&#10;&#10;# Ignore downloads&#10;/tmp/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import shutil&#10;import tempfile&#10;import yt_dlp&#10;from fastapi import FastAPI, HTTPException, BackgroundTasks&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from pydantic import BaseModel&#10;from starlette.responses import FileResponse&#10;&#10;app = FastAPI()&#10;origins = [&quot;http://localhost:3000&quot;]&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=origins,&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;&#10;class VideoRequest(BaseModel):&#10;    url: str&#10;&#10;&#10;class DownloadRequest(BaseModel):&#10;    url: str&#10;    quality_label: str&#10;&#10;&#10;def cleanup_directory(path: str):&#10;    if os.path.isdir(path):&#10;        shutil.rmtree(path)&#10;&#10;&#10;@app.post(&quot;/api/info&quot;)&#10;def get_video_info(request: VideoRequest):&#10;    ydl_opts = {'quiet': True}&#10;    try:&#10;        with yt_dlp.YoutubeDL(ydl_opts) as ydl:&#10;            info = ydl.extract_info(request.url, download=False)&#10;&#10;            qualities = set()&#10;            for f in info.get('formats', []):&#10;                if f.get('vcodec') != 'none' and f.get('acodec') == 'none' and f.get('height'):&#10;                    qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            if not qualities:  # Fallback for videos with combined formats only&#10;                for f in info.get('formats', []):&#10;                    if f.get('vcodec') != 'none' and f.get('height'):&#10;                        qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            sorted_qualities = sorted(list(qualities), key=lambda x: int(x.replace('p', '')), reverse=True)&#10;&#10;            return {&#10;                &quot;title&quot;: info.get(&quot;title&quot;, &quot;No title&quot;),&#10;                &quot;thumbnail&quot;: info.get(&quot;thumbnail&quot;, &quot;&quot;),&#10;                &quot;qualities&quot;: sorted_qualities,&#10;            }&#10;    except Exception as e:&#10;        raise HTTPException(status_code=400, detail=str(e))&#10;&#10;&#10;@app.post(&quot;/api/download&quot;)&#10;async def download_video(request: DownloadRequest, background_tasks: BackgroundTasks):&#10;    temp_dir = tempfile.mkdtemp()&#10;    background_tasks.add_task(cleanup_directory, temp_dir)&#10;&#10;    try:&#10;        # --- Stage 1: Always download the best quality to avoid 403 errors ---&#10;        source_path_template = os.path.join(temp_dir, 'source_video')&#10;        source_path_final = f&quot;{source_path_template}.mp4&quot;&#10;&#10;        ydl_opts_best = {&#10;            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',&#10;            'outtmpl': source_path_template,&#10;            'quiet': True,&#10;            'merge_output_format': 'mp4',&#10;        }&#10;&#10;        with yt_dlp.YoutubeDL(ydl_opts_best) as ydl:&#10;            info = ydl.extract_info(request.url, download=True)&#10;            title = info.get(&quot;title&quot;, &quot;video&quot;)&#10;            # Get the actual height of the video we just downloaded&#10;            actual_height = info.get('height')&#10;&#10;        if not os.path.exists(source_path_final):&#10;            raise HTTPException(status_code=500, detail=&quot;Failed to download the source video.&quot;)&#10;&#10;        # --- Stage 2: Check if re-encoding is necessary ---&#10;        requested_height = int(re.search(r'(\d+)p', request.quality_label).group(1))&#10;&#10;        # If requested quality is the same or higher than best, no need to re-encode&#10;        if requested_height &gt;= actual_height:&#10;            safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;            return FileResponse(path=source_path_final, media_type='video/mp4', filename=safe_filename)&#10;&#10;        # --- Stage 3: Re-encode to the desired lower quality ---&#10;        final_path = os.path.join(temp_dir, 'final_video.mp4')&#10;&#10;        # This ffmpeg command scales the video down to the requested height&#10;        ffmpeg_command = [&#10;            'ffmpeg',&#10;            '-i', source_path_final,&#10;            '-vf', f'scale=-2:{requested_height}',  # -2 maintains aspect ratio&#10;            '-c:a', 'copy',  # Copy the audio stream without re-encoding&#10;            final_path&#10;        ]&#10;&#10;        # Using subprocess.run to execute the command&#10;        process = subprocess.run(&#10;            ffmpeg_command,&#10;            capture_output=True,&#10;            text=True,&#10;            check=False  # Set to False to check stderr manually&#10;        )&#10;&#10;        if process.returncode != 0:&#10;            # If ffmpeg fails, raise an error with its output for debugging&#10;            print(&quot;FFmpeg Error:&quot;, process.stderr)&#10;            raise HTTPException(status_code=500, detail=f&quot;FFmpeg re-encoding failed: {process.stderr}&quot;)&#10;&#10;        if not os.path.exists(final_path):&#10;            raise HTTPException(status_code=500, detail=&quot;Re-encoding failed to produce an output file.&quot;)&#10;&#10;        safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;        return FileResponse(path=final_path, media_type='video/mp4', filename=safe_filename)&#10;&#10;    except Exception as e:&#10;        if isinstance(e, HTTPException):&#10;            raise e&#10;        print(f&quot;An error occurred in /api/download: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=str(e))" />
              <option name="updatedContent" value="import os&#10;import re&#10;import shutil&#10;import subprocess&#10;import tempfile&#10;import yt_dlp&#10;from fastapi import FastAPI, HTTPException, BackgroundTasks&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from pydantic import BaseModel&#10;from starlette.responses import FileResponse&#10;&#10;app = FastAPI()&#10;origins = [&quot;http://localhost:3000&quot;]&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=origins,&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;&#10;class VideoRequest(BaseModel):&#10;    url: str&#10;&#10;&#10;class DownloadRequest(BaseModel):&#10;    url: str&#10;    quality_label: str&#10;&#10;&#10;def cleanup_directory(path: str):&#10;    if os.path.isdir(path):&#10;        shutil.rmtree(path)&#10;&#10;&#10;@app.post(&quot;/api/info&quot;)&#10;def get_video_info(request: VideoRequest):&#10;    ydl_opts = {'quiet': True}&#10;    try:&#10;        with yt_dlp.YoutubeDL(ydl_opts) as ydl:&#10;            info = ydl.extract_info(request.url, download=False)&#10;&#10;            qualities = set()&#10;            for f in info.get('formats', []):&#10;                if f.get('vcodec') != 'none' and f.get('acodec') == 'none' and f.get('height'):&#10;                    qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            if not qualities:  # Fallback for videos with combined formats only&#10;                for f in info.get('formats', []):&#10;                    if f.get('vcodec') != 'none' and f.get('height'):&#10;                        qualities.add(f&quot;{f['height']}p&quot;)&#10;&#10;            sorted_qualities = sorted(list(qualities), key=lambda x: int(x.replace('p', '')), reverse=True)&#10;&#10;            return {&#10;                &quot;title&quot;: info.get(&quot;title&quot;, &quot;No title&quot;),&#10;                &quot;thumbnail&quot;: info.get(&quot;thumbnail&quot;, &quot;&quot;),&#10;                &quot;qualities&quot;: sorted_qualities,&#10;            }&#10;    except Exception as e:&#10;        raise HTTPException(status_code=400, detail=str(e))&#10;&#10;&#10;@app.post(&quot;/api/download&quot;)&#10;async def download_video(request: DownloadRequest, background_tasks: BackgroundTasks):&#10;    temp_dir = tempfile.mkdtemp()&#10;    background_tasks.add_task(cleanup_directory, temp_dir)&#10;&#10;    try:&#10;        # --- Stage 1: Always download the best quality to avoid 403 errors ---&#10;        source_path_template = os.path.join(temp_dir, 'source_video')&#10;        source_path_final = f&quot;{source_path_template}.mp4&quot;&#10;&#10;        ydl_opts_best = {&#10;            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',&#10;            'outtmpl': source_path_template,&#10;            'quiet': True,&#10;            'merge_output_format': 'mp4',&#10;        }&#10;&#10;        with yt_dlp.YoutubeDL(ydl_opts_best) as ydl:&#10;            info = ydl.extract_info(request.url, download=True)&#10;            title = info.get(&quot;title&quot;, &quot;video&quot;)&#10;            # Get the actual height of the video we just downloaded&#10;            actual_height = info.get('height')&#10;&#10;        if not os.path.exists(source_path_final):&#10;            raise HTTPException(status_code=500, detail=&quot;Failed to download the source video.&quot;)&#10;&#10;        # --- Stage 2: Check if re-encoding is necessary ---&#10;        requested_height = int(re.search(r'(\d+)p', request.quality_label).group(1))&#10;&#10;        # If requested quality is the same or higher than best, no need to re-encode&#10;        if requested_height &gt;= actual_height:&#10;            safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;            return FileResponse(path=source_path_final, media_type='video/mp4', filename=safe_filename)&#10;&#10;        # --- Stage 3: Re-encode to the desired lower quality ---&#10;        final_path = os.path.join(temp_dir, 'final_video.mp4')&#10;&#10;        # This ffmpeg command scales the video down to the requested height&#10;        ffmpeg_command = [&#10;            'ffmpeg',&#10;            '-i', source_path_final,&#10;            '-vf', f'scale=-2:{requested_height}',  # -2 maintains aspect ratio&#10;            '-c:a', 'copy',  # Copy the audio stream without re-encoding&#10;            final_path&#10;        ]&#10;&#10;        # Using subprocess.run to execute the command&#10;        process = subprocess.run(&#10;            ffmpeg_command,&#10;            capture_output=True,&#10;            text=True,&#10;            check=False  # Set to False to check stderr manually&#10;        )&#10;&#10;        if process.returncode != 0:&#10;            # If ffmpeg fails, raise an error with its output for debugging&#10;            print(&quot;FFmpeg Error:&quot;, process.stderr)&#10;            raise HTTPException(status_code=500, detail=f&quot;FFmpeg re-encoding failed: {process.stderr}&quot;)&#10;&#10;        if not os.path.exists(final_path):&#10;            raise HTTPException(status_code=500, detail=&quot;Re-encoding failed to produce an output file.&quot;)&#10;&#10;        safe_filename = &quot;&quot;.join([c for c in title if c.isalnum() or c in (' ', '-')]).rstrip() + &quot;.mp4&quot;&#10;        return FileResponse(path=final_path, media_type='video/mp4', filename=safe_filename)&#10;&#10;    except Exception as e:&#10;        if isinstance(e, HTTPException):&#10;            raise e&#10;        print(f&quot;An error occurred in /api/download: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=str(e))" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/readme.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/readme.md" />
              <option name="updatedContent" value="# YouTube Downloader Project&#10;&#10;**This repository is for learning purposes and experimentation.**&#10;&#10;## Overview&#10;This project demonstrates how to build a full-stack YouTube downloader using FastAPI (Python) for the backend and Next.js (React/TypeScript) for the frontend. It is designed to help developers and other staff understand modern web development workflows, API integration, and media processing.&#10;&#10;## Features&#10;- Fetch YouTube video metadata and available formats&#10;- Download and merge video/audio streams&#10;- Select video quality and download as MP4&#10;- Simple, user-friendly frontend&#10;&#10;## Technologies Used&#10;- Python (FastAPI, yt-dlp)&#10;- Node.js (Next.js, React, TypeScript)&#10;- FFmpeg (for media merging and conversion)&#10;&#10;## Disclaimer&#10;**This project is strictly for educational and internal staff use.**&#10;Do not use this tool for any commercial or copyright-infringing activities. Always respect YouTube's Terms of Service and copyright laws.&#10;&#10;## Getting Started&#10;1. Clone the repository&#10;2. Install backend and frontend dependencies&#10;3. Run the FastAPI backend&#10;4. Run the Next.js frontend&#10;&#10;## License&#10;This code is provided as-is for learning and staff development. No warranty or support is provided.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ytd-frontend/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ytd-frontend/README.md" />
              <option name="originalContent" value="This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).&#10;&#10;## Getting Started&#10;&#10;First, run the development server:&#10;&#10;```bash&#10;npm run dev&#10;# or&#10;yarn dev&#10;# or&#10;pnpm dev&#10;# or&#10;bun dev&#10;```&#10;&#10;Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.&#10;&#10;You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.&#10;&#10;This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.&#10;&#10;## Learn More&#10;&#10;To learn more about Next.js, take a look at the following resources:&#10;&#10;- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.&#10;- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.&#10;&#10;You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!&#10;&#10;## Deploy on Vercel&#10;&#10;The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&amp;filter=next.js&amp;utm_source=create-next-app&amp;utm_campaign=create-next-app-readme) from the creators of Next.js.&#10;&#10;Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.&#10;" />
              <option name="updatedContent" value="# YouTube Downloader Frontend&#10;&#10;**This frontend is for learning purposes and experimentation by developers and staff.**&#10;&#10;## Overview&#10;This is the React/Next.js frontend for the YouTube Downloader project. It provides a simple and modern user interface for interacting with the FastAPI backend, allowing users to search for YouTube videos, select quality, and download them.&#10;&#10;## Features&#10;- Search and preview YouTube videos&#10;- Display available video qualities and metadata&#10;- Download selected video quality via backend API&#10;- Responsive and user-friendly design&#10;&#10;## Technologies Used&#10;- React&#10;- Next.js&#10;- TypeScript&#10;- Tailwind CSS (if used)&#10;&#10;## Disclaimer&#10;**This project is strictly for educational and internal staff use.**&#10;Do not use this tool for any commercial or copyright-infringing activities. Always respect YouTube's Terms of Service and copyright laws.&#10;&#10;## Getting Started&#10;1. Install dependencies: `npm install`&#10;2. Start the development server: `npm run dev`&#10;3. Access the frontend at `http://localhost:3000`&#10;&#10;## License&#10;This code is provided as-is for learning and staff development. No warranty or support is provided.&#10;&#10;This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).&#10;&#10;## Getting Started&#10;&#10;First, run the development server:&#10;&#10;```bash&#10;npm run dev&#10;# or&#10;yarn dev&#10;# or&#10;pnpm dev&#10;# or&#10;bun dev&#10;```&#10;&#10;Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.&#10;&#10;You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.&#10;&#10;This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.&#10;&#10;## Learn More&#10;&#10;To learn more about Next.js, take a look at the following resources:&#10;&#10;- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.&#10;- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.&#10;&#10;You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!&#10;&#10;## Deploy on Vercel&#10;&#10;The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&amp;filter=next.js&amp;utm_source=create-next-app&amp;utm_campaign=create-next-app-readme) from the creators of Next.js.&#10;&#10;Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>